apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: vault
  namespace: vault 
spec:
  interval: 5m
  chart:
    spec:
      chart: vault 
      version: '0.31.*' 
      sourceRef:
        kind: HelmRepository
        name: vault
        namespace: vault
  values:
    global:
      enabled: true
      tlsDisable: true
      serverTelemetry:
        prometheusOperator: false
    injector:
      enabled: "-"
      replicas: 1
      port: 8080
      leaderElector:
        enabled: true
      metrics:
        enabled: false
      externalVaultAddr: ""
      image:
        repository: "hashicorp/vault-k8s"
        tag: "1.7.0"
        pullPolicy: IfNotPresent
      agentImage:
        repository: "hashicorp/vault"
        tag: "1.20.4"
        cpuLimit: "500m"
        cpuRequest: "250m"
        memLimit: "128Mi"
        memRequest: "64Mi"
        # ephemeralLimit: "128Mi"
        # ephemeralRequest: "64Mi"

        # Default template type for secrets when no custom template is specified.
        # Possible values include: "json" and "map".
        template: "map"

        # Default values within Agent's template_config stanza.
        templateConfig:
          exitOnRetryFailure: true
          staticSecretRenderInterval: ""

      # Used to define custom livenessProbe settings
      livenessProbe:
        # When a probe fails, Kubernetes will try failureThreshold times before giving up
        failureThreshold: 2
        # Number of seconds after the container has started before probe initiates
        initialDelaySeconds: 5
        # How often (in seconds) to perform the probe
        periodSeconds: 2
        # Minimum consecutive successes for the probe to be considered successful after having failed
        successThreshold: 1
        # Number of seconds after which the probe times out.
        timeoutSeconds: 5
      # Used to define custom readinessProbe settings
      readinessProbe:
        # When a probe fails, Kubernetes will try failureThreshold times before giving up
        failureThreshold: 2
        # Number of seconds after the container has started before probe initiates
        initialDelaySeconds: 5
        # How often (in seconds) to perform the probe
        periodSeconds: 2
        # Minimum consecutive successes for the probe to be considered successful after having failed
        successThreshold: 1
        # Number of seconds after which the probe times out.
        timeoutSeconds: 5
      # Used to define custom startupProbe settings
      startupProbe:
        # When a probe fails, Kubernetes will try failureThreshold times before giving up
        failureThreshold: 12
        # Number of seconds after the container has started before probe initiates
        initialDelaySeconds: 5
        # How often (in seconds) to perform the probe
        periodSeconds: 5
        # Minimum consecutive successes for the probe to be considered successful after having failed
        successThreshold: 1
        # Number of seconds after which the probe times out.
        timeoutSeconds: 5

      # Mount Path of the Vault Kubernetes Auth Method.
      authPath: "auth/kubernetes"

      # Configures the log verbosity of the injector.
      # Supported log levels include: trace, debug, info, warn, error
      logLevel: "info"

      # Configures the log format of the injector. Supported log formats: "standard", "json".
      logFormat: "standard"

      # Configures all Vault Agent sidecars to revoke their token when shutting down
      revokeOnShutdown: false

      webhook:
        # Configures failurePolicy of the webhook. The "unspecified" default behaviour depends on the
        # API Version of the WebHook.
        # To block pod creation while the webhook is unavailable, set the policy to `Fail` below.
        # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy
        #
        failurePolicy: Ignore

        # matchPolicy specifies the approach to accepting changes based on the rules of
        # the MutatingWebhookConfiguration.
        # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-matchpolicy
        # for more details.
        #
        matchPolicy: Exact

        # timeoutSeconds is the amount of seconds before the webhook request will be ignored
        # or fails.
        # If it is ignored or fails depends on the failurePolicy
        # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#timeouts
        # for more details.
        #
        timeoutSeconds: 30

        # namespaceSelector is the selector for restricting the webhook to only
        # specific namespaces.
        # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector
        # for more details.
        # Example:
        # namespaceSelector:
        #    matchLabels:
        #      sidecar-injector: enabled
        namespaceSelector: {}

        # objectSelector is the selector for restricting the webhook to only
        # specific labels.
        # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector
        # for more details.
        # Example:
        # objectSelector:
        #    matchLabels:
        #      vault-sidecar-injector: enabled
        objectSelector: |
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: NotIn
            values:
            - {{ template "vault.name" . }}-agent-injector

        # Extra annotations to attach to the webhook
        annotations: {}

      # Deprecated: please use 'webhook.failurePolicy' instead
      # Configures failurePolicy of the webhook. The "unspecified" default behaviour depends on the
      # API Version of the WebHook.
      # To block pod creation while webhook is unavailable, set the policy to `Fail` below.
      # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy
      #
      failurePolicy: Ignore

      # Deprecated: please use 'webhook.namespaceSelector' instead
      # namespaceSelector is the selector for restricting the webhook to only
      # specific namespaces.
      # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector
      # for more details.
      # Example:
      # namespaceSelector:
      #    matchLabels:
      #      sidecar-injector: enabled
      namespaceSelector: {}

      # Deprecated: please use 'webhook.objectSelector' instead
      # objectSelector is the selector for restricting the webhook to only
      # specific labels.
      # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector
      # for more details.
      # Example:
      # objectSelector:
      #    matchLabels:
      #      vault-sidecar-injector: enabled
      objectSelector: {}

      # Deprecated: please use 'webhook.annotations' instead
      # Extra annotations to attach to the webhook
      webhookAnnotations: {}

      certs:
        # secretName is the name of the secret that has the TLS certificate and
        # private key to serve the injector webhook. If this is null, then the
        # injector will default to its automatic management mode that will assign
        # a service account to the injector to generate its own certificates.
        secretName: null

        # caBundle is a base64-encoded PEM-encoded certificate bundle for the CA
        # that signed the TLS certificate that the webhook serves. This must be set
        # if secretName is non-null unless an external service like cert-manager is
        # keeping the caBundle updated.
        caBundle: ""

        # certName and keyName are the names of the files within the secret for
        # the TLS cert and private key, respectively. These have reasonable
        # defaults but can be customized if necessary.
        certName: tls.crt
        keyName: tls.key

      # Security context for the pod template and the injector container
      # The default pod securityContext is:
      #   runAsNonRoot: true
      #   runAsGroup: {{ .Values.injector.gid | default 1000 }}
      #   runAsUser: {{ .Values.injector.uid | default 100 }}
      #   fsGroup: {{ .Values.injector.gid | default 1000 }}
      # and for container is
      #    allowPrivilegeEscalation: false
      #    capabilities:
      #      drop:
      #        - ALL
      securityContext:
        pod: {}
        container: {}

      resources:
        requests:
          memory: 256Mi
          cpu: 250m
        limits:
          memory: 256Mi
          cpu: 250m

      extraEnvironmentVars: {}
      affinity: |
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchLabels:
                  app.kubernetes.io/name: {{ template "vault.name" . }}-agent-injector
                  app.kubernetes.io/instance: "{{ .Release.Name }}"
                  component: webhook
              topologyKey: kubernetes.io/hostname

      # Topology settings for injector pods
      # ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
      # This should be either a multi-line string or YAML matching the topologySpreadConstraints array
      # in a PodSpec.
      topologySpreadConstraints: []

      # Toleration Settings for injector pods
      # This should be either a multi-line string or YAML matching the Toleration array
      # in a PodSpec.
      tolerations: []

      # nodeSelector labels for server pod assignment, formatted as a multi-line string or YAML map.
      # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
      # Example:
      # nodeSelector:
      #   beta.kubernetes.io/arch: amd64
      nodeSelector: {}

      # Priority class for injector pods
      priorityClassName: ""

      # Extra annotations to attach to the injector pods
      # This can either be YAML or a YAML-formatted multi-line templated string map
      # of the annotations to apply to the injector pods
      annotations: {}

      # Extra labels to attach to the agent-injector
      # This should be a YAML map of the labels to apply to the injector
      extraLabels: {}

      # Should the injector pods run on the host network (useful when using
      # an alternate CNI in EKS)
      hostNetwork: false

      # Injector service specific config
      service:
        # Extra annotations to attach to the injector service
        annotations: {}

      # Injector serviceAccount specific config
      serviceAccount:
        # Extra annotations to attach to the injector serviceAccount
        annotations: {}

      # A disruption budget limits the number of pods of a replicated application
      # that are down simultaneously from voluntary disruptions
      podDisruptionBudget: {}
      # podDisruptionBudget:
      #   maxUnavailable: 1

      # strategy for updating the deployment. This can be a multi-line string or a
      # YAML map.
      strategy: {}
      # strategy: |
      #   rollingUpdate:
      #     maxSurge: 25%
      #     maxUnavailable: 25%
      #   type: RollingUpdate

    server:
      # If true, or "-" with global.enabled true, Vault server will be installed.
      # See vault.mode in _helpers.tpl for implementation details.
      enabled: "-"

      # [Enterprise Only] This value refers to a Kubernetes secret that you have
      # created that contains your enterprise license. If you are not using an
      # enterprise image or if you plan to introduce the license key via another
      # route, then leave secretName blank ("") or set it to null.
      # Requires Vault Enterprise 1.8 or later.
      enterpriseLicense:
        # The name of the Kubernetes secret that holds the enterprise license. The
        # secret must be in the same namespace that Vault is installed into.
        secretName: ""
        # The key within the Kubernetes secret that holds the enterprise license.
        secretKey: "license"

      image:
        repository: "hashicorp/vault"
        tag: "1.20.4"
        # Overrides the default Image Pull Policy
        pullPolicy: IfNotPresent

      # Configure the Update Strategy Type for the StatefulSet
      # See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
      updateStrategyType: "OnDelete"

      # Configure the logging verbosity for the Vault server.
      # Supported log levels include: trace, debug, info, warn, error
      logLevel: ""

      # Configure the logging format for the Vault server.
      # Supported log formats include: standard, json
      logFormat: ""
      
      # Resource requests, limits, etc. for the server cluster placement. This
      # should map directly to the value of the resources field for a PodSpec.
      # By default no direct resource request is made.
      resources: {}
      # resources:
      #   requests:
      #     memory: 256Mi
      #     cpu: 250m
      #   limits:
      #     memory: 256Mi
      #     cpu: 250m

      # Ingress allows ingress services to be created to allow external access
      # from Kubernetes to access Vault pods.
      # If deployment is on OpenShift, the following block is ignored.
      # In order to expose the service, use the route section below
      ingress:
        enabled: false
        labels: {}
          # traffic: external
        annotations: {}
          # |
          # kubernetes.io/ingress.class: nginx
          # kubernetes.io/tls-acme: "true"
          #   or
          # kubernetes.io/ingress.class: nginx
          # kubernetes.io/tls-acme: "true"

        # Optionally use ingressClassName instead of deprecated annotation.
        # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#deprecated-annotation
        ingressClassName: ""

        # As of Kubernetes 1.19, all Ingress Paths must have a pathType configured. The default value below should be sufficient in most cases.
        # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types for other possible values.
        pathType: Prefix

        # When HA mode is enabled and K8s service registration is being used,
        # configure the ingress to point to the Vault active service.
        activeService: true
        hosts:
          - host: chart-example.local
            paths: []
        ## Extra paths to prepend to the host configuration. This is useful when working with annotation based services.
        extraPaths: []
        # - path: /*
        #   backend:
        #     service:
        #       name: ssl-redirect
        #       port:
        #         number: use-annotation
        tls: []
        #  - secretName: chart-example-tls
        #    hosts:
        #      - chart-example.local

      # hostAliases is a list of aliases to be added to /etc/hosts. Specified as a YAML list.
      hostAliases: []
      # - ip: 127.0.0.1
      #   hostnames:
      #     - chart-example.local

      # OpenShift only - create a route to expose the service
      # By default the created route will be of type passthrough
      route:
        enabled: false

        # When HA mode is enabled and K8s service registration is being used,
        # configure the route to point to the Vault active service.
        activeService: true

        labels: {}
        annotations: {}
        host: chart-example.local
        # tls will be passed directly to the route's TLS config, which
        # can be used to configure other termination methods that terminate
        # TLS at the router
        tls:
          termination: passthrough

      # authDelegator enables a cluster role binding to be attached to the service
      # account.  This cluster role binding can be used to setup Kubernetes auth
      # method. See https://developer.hashicorp.com/vault/docs/auth/kubernetes
      authDelegator:
        enabled: true

      # extraInitContainers is a list of init containers. Specified as a YAML list.
      # This is useful if you need to run a script to provision TLS certificates or
      # write out configuration files in a dynamic way.
      extraInitContainers: null
        # # This example installs a plugin pulled from github into the /usr/local/libexec/vault/oauthapp folder,
        # # which is defined in the volumes value.
        # - name: oauthapp
        #   image: "alpine"
        #   command: [sh, -c]
        #   args:
        #     - cd /tmp &&
        #       wget https://github.com/puppetlabs/vault-plugin-secrets-oauthapp/releases/download/v1.2.0/vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64.tar.xz -O oauthapp.xz &&
        #       tar -xf oauthapp.xz &&
        #       mv vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64 /usr/local/libexec/vault/oauthapp &&
        #       chmod +x /usr/local/libexec/vault/oauthapp
        #   volumeMounts:
        #     - name: plugins
        #       mountPath: /usr/local/libexec/vault

      # extraContainers is a list of sidecar containers. Specified as a YAML list.
      extraContainers: null

      # shareProcessNamespace enables process namespace sharing between Vault and the extraContainers
      # This is useful if Vault must be signaled, e.g. to send a SIGHUP for a log rotation
      shareProcessNamespace: false

      # extraArgs is a string containing additional Vault server arguments.
      extraArgs: ""

      # extraPorts is a list of extra ports. Specified as a YAML list.
      # This is useful if you need to add additional ports to the statefulset in dynamic way.
      extraPorts: null
        # - containerPort: 8300
        #   name: http-monitoring

      # Used to define custom readinessProbe settings
      readinessProbe:
        enabled: true
        # If you need to use a http path instead of the default exec
        # path: /v1/sys/health?standbyok=true

        # Port number on which readinessProbe will be checked.
        port: 8200
        # When a probe fails, Kubernetes will try failureThreshold times before giving up
        failureThreshold: 2
        # Number of seconds after the container has started before probe initiates
        initialDelaySeconds: 5
        # How often (in seconds) to perform the probe
        periodSeconds: 5
        # Minimum consecutive successes for the probe to be considered successful after having failed
        successThreshold: 1
        # Number of seconds after which the probe times out.
        timeoutSeconds: 3
      # Used to enable a livenessProbe for the pods
      livenessProbe:
        enabled: false
        # Used to define a liveness exec command. If provided, exec is preferred to httpGet (path) as the livenessProbe handler.
        execCommand: []
        # - /bin/sh
        # - -c
        # - /vault/userconfig/mylivenessscript/run.sh
        # Path for the livenessProbe to use httpGet as the livenessProbe handler
        path: "/v1/sys/health?standbyok=true"
        # Port number on which livenessProbe will be checked if httpGet is used as the livenessProbe handler
        port: 8200
        # When a probe fails, Kubernetes will try failureThreshold times before giving up
        failureThreshold: 2
        # Number of seconds after the container has started before probe initiates
        initialDelaySeconds: 60
        # How often (in seconds) to perform the probe
        periodSeconds: 5
        # Minimum consecutive successes for the probe to be considered successful after having failed
        successThreshold: 1
        # Number of seconds after which the probe times out.
        timeoutSeconds: 3

      # Optional duration in seconds the pod needs to terminate gracefully.
      # See: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
      terminationGracePeriodSeconds: 10

      # Used to set the sleep time during the preStop step, if custom preStop
      # commands are not set.
      preStopSleepSeconds: 5

      # Used to define custom preStop exec commands to run before the pod is
      # terminated. If not set, this will default to:
      # preStop:
      #   - "/bin/sh"
      #   - "-c"
      #   - "sleep {{ .Values.server.preStopSleepSeconds }} && kill -SIGTERM $(pidof vault)"
      preStop: []

      # Used to define commands to run after the pod is ready.
      # This can be used to automate processes such as initialization
      # or boostrapping auth methods.
      postStart: []
      # - /bin/sh
      # - -c
      # - /vault/userconfig/myscript/run.sh

      # extraEnvironmentVars is a list of extra environment variables to set with the stateful set. These could be
      # used to include variables required for auto-unseal.
      extraEnvironmentVars: {}
        # GOOGLE_REGION: global
        # GOOGLE_PROJECT: myproject
        # GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/myproject/myproject-creds.json

      # extraSecretEnvironmentVars is a list of extra environment variables to set with the stateful set.
      # These variables take value from existing Secret objects.
      extraSecretEnvironmentVars: []
        # - envName: AWS_SECRET_ACCESS_KEY
        #   secretName: vault
        #   secretKey: AWS_SECRET_ACCESS_KEY

      # Deprecated: please use 'volumes' instead.
      # extraVolumes is a list of extra volumes to mount. These will be exposed
      # to Vault in the path `/vault/userconfig/<name>/`. The value below is
      # an array of objects, examples are shown below.
      extraVolumes: []
        # - type: secret (or "configMap")
        #   name: my-secret
        #   path: null # default is `/vault/userconfig`

      # volumes is a list of volumes made available to all containers. These are rendered
      # via toYaml rather than pre-processed like the extraVolumes value.
      # The purpose is to make it easy to share volumes between containers.
      volumes: null
      #   - name: plugins
      #     emptyDir: {}

      # volumeMounts is a list of volumeMounts for the main server container. These are rendered
      # via toYaml rather than pre-processed like the extraVolumes value.
      # The purpose is to make it easy to share volumes between containers.
      volumeMounts: null
      #   - mountPath: /usr/local/libexec/vault
      #     name: plugins
      #     readOnly: true

      # Affinity Settings
      # Commenting out or setting as empty the affinity variable, will allow
      # deployment to single node services such as Minikube
      # This should be either a multi-line string or YAML matching the PodSpec's affinity field.
      affinity: |
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchLabels:
                  app.kubernetes.io/name: {{ template "vault.name" . }}
                  app.kubernetes.io/instance: "{{ .Release.Name }}"
                  component: server
              topologyKey: kubernetes.io/hostname

      # Topology settings for server pods
      # ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
      # This should be either a multi-line string or YAML matching the topologySpreadConstraints array
      # in a PodSpec.
      topologySpreadConstraints: []

      # Toleration Settings for server pods
      # This should be either a multi-line string or YAML matching the Toleration array
      # in a PodSpec.
      tolerations: []

      # nodeSelector labels for server pod assignment, formatted as a multi-line string or YAML map.
      # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
      # Example:
      # nodeSelector:
      #   beta.kubernetes.io/arch: amd64
      nodeSelector: {}

      # Enables network policy for server pods
      networkPolicy:
        enabled: false
        egress: []
        # egress:
        # - to:
        #   - ipBlock:
        #       cidr: 10.0.0.0/24
        #   ports:
        #   - protocol: TCP
        #     port: 443
        ingress:
          - from:
            - namespaceSelector: {}
            ports:
            - port: 8200
              protocol: TCP
            - port: 8201
              protocol: TCP

      # Priority class for server pods
      priorityClassName: ""

      # Extra labels to attach to the server pods
      # This should be a YAML map of the labels to apply to the server pods
      extraLabels: {}

      # Extra annotations to attach to the server pods
      # This can either be YAML or a YAML-formatted multi-line templated string map
      # of the annotations to apply to the server pods
      annotations: {}

      # Add an annotation to the server configmap and the statefulset pods,
      # vaultproject.io/config-checksum, that is a hash of the Vault configuration.
      # This can be used together with an OnDelete deployment strategy to help
      # identify which pods still need to be deleted during a deployment to pick up
      # any configuration changes.
      includeConfigAnnotation: false

      # Enables a headless service to be used by the Vault Statefulset
      service:
        enabled: true
        # Enable or disable the vault-active service, which selects Vault pods that
        # have labeled themselves as the cluster leader with `vault-active: "true"`.
        active:
          enabled: true
          # Extra annotations for the service definition. This can either be YAML or a
          # YAML-formatted multi-line templated string map of the annotations to apply
          # to the active service.
          annotations: {}
        # Enable or disable the vault-standby service, which selects Vault pods that
        # have labeled themselves as a cluster follower with `vault-active: "false"`.
        standby:
          enabled: true
          # Extra annotations for the service definition. This can either be YAML or a
          # YAML-formatted multi-line templated string map of the annotations to apply
          # to the standby service.
          annotations: {}
        # If enabled, the service selectors will include `app.kubernetes.io/instance: {{ .Release.Name }}`
        # When disabled, services may select Vault pods not deployed from the chart.
        # Does not affect the headless vault-internal service with `ClusterIP: None`
        instanceSelector:
          enabled: true
        # clusterIP controls whether a Cluster IP address is attached to the
        # Vault service within Kubernetes.  By default, the Vault service will
        # be given a Cluster IP address, set to None to disable.  When disabled
        # Kubernetes will create a "headless" service.  Headless services can be
        # used to communicate with pods directly through DNS instead of a round-robin
        # load balancer.
        # clusterIP: None

        # Configures the service type for the main Vault service.  Can be ClusterIP
        # or NodePort.
        #type: ClusterIP

        # The IP family and IP families options are to set the behaviour in a dual-stack environment.
        # Omitting these values will let the service fall back to whatever the CNI dictates the defaults
        # should be.
        # These are only supported for kubernetes versions >=1.23.0
        #
        # Configures the service's supported IP family policy, can be either:
        #     SingleStack: Single-stack service. The control plane allocates a cluster IP for the Service, using the first configured service cluster IP range.
        #     PreferDualStack: Allocates IPv4 and IPv6 cluster IPs for the Service.
        #     RequireDualStack: Allocates Service .spec.ClusterIPs from both IPv4 and IPv6 address ranges.
        ipFamilyPolicy: ""
        ipFamilies: []

        # Do not wait for pods to be ready before including them in the services'
        # targets. Does not apply to the headless service, which is used for
        # cluster-internal communication.
        publishNotReadyAddresses: true

        # The externalTrafficPolicy can be set to either Cluster or Local
        # and is only valid for LoadBalancer and NodePort service types.
        # The default value is Cluster.
        # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy
        externalTrafficPolicy: Cluster
        port: 8200
        targetPort: 8200
        annotations: {}
      dataStorage:
        enabled: true
        size: 20Gi
        mountPath: "/vault/data"
        storageClass: iscsi 
        accessMode: ReadWriteOnce
        annotations: {}
        labels: {}
      persistentVolumeClaimRetentionPolicy: {}
      auditStorage:
        enabled: false
        size: 20Gi
        mountPath: "/vault/audit"
        storageClass: iscsi
        accessMode: ReadWriteOnce
        annotations: {}
        labels: {}
      dev:
        enabled: false
        devRootToken: "root"
      standalone:
        enabled: "-"
        config: |-
          ui = true

          listener "tcp" {
            tls_disable = 1
            address = "[::]:8200"
            cluster_address = "[::]:8201"
            # Enable unauthenticated metrics access (necessary for Prometheus Operator)
            #telemetry {
            #  unauthenticated_metrics_access = "true"
            #}
          }
          storage "file" {
            path = "/vault/data"
          }

          # Example configuration for using auto-unseal, using Google Cloud KMS. The
          # GKMS keys must already exist, and the cluster must have a service account
          # that is authorized to access GCP KMS.
          #seal "gcpckms" {
          #   project     = "vault-helm-dev"
          #   region      = "global"
          #   key_ring    = "vault-helm-unseal-kr"
          #   crypto_key  = "vault-helm-unseal-key"
          #}

          # Example configuration for enabling Prometheus metrics in your config.
          #telemetry {
          #  prometheus_retention_time = "30s"
          #  disable_hostname = true
          #}
      ha:
        enabled: false
        replicas: 3
        apiAddr: null
        clusterAddr: null
        raft:
          enabled: false
          setNodeId: false
          config: |
            ui = true

            listener "tcp" {
              tls_disable = 1
              address = "[::]:8200"
              cluster_address = "[::]:8201"
              # Enable unauthenticated metrics access (necessary for Prometheus Operator)
              #telemetry {
              #  unauthenticated_metrics_access = "true"
              #}
            }

            storage "raft" {
              path = "/vault/data"
            }

            service_registration "kubernetes" {}
        config: |
          ui = true

          listener "tcp" {
            tls_disable = 1
            address = "[::]:8200"
            cluster_address = "[::]:8201"
          }
          storage "consul" {
            path = "vault"
            address = "HOST_IP:8500"
          }

          service_registration "kubernetes" {}

          # Example configuration for using auto-unseal, using Google Cloud KMS. The
          # GKMS keys must already exist, and the cluster must have a service account
          # that is authorized to access GCP KMS.
          #seal "gcpckms" {
          #   project     = "vault-helm-dev-246514"
          #   region      = "global"
          #   key_ring    = "vault-helm-unseal-kr"
          #   crypto_key  = "vault-helm-unseal-key"
          #}

          # Example configuration for enabling Prometheus metrics.
          # If you are using Prometheus Operator you can enable a ServiceMonitor resource below.
          # You may wish to enable unauthenticated metrics in the listener block above.
          #telemetry {
          #  prometheus_retention_time = "30s"
          #  disable_hostname = true
          #}

        disruptionBudget:
          enabled: true
          maxUnavailable: null
      serviceAccount:
        create: true
        name: ""
        createSecret: false
        annotations: {}
        extraLabels: {}
        serviceDiscovery:
          enabled: true
      statefulSet:
        annotations: {}
        securityContext:
          pod: {}
          container: {}
      hostNetwork: false

    ui:
      enabled: false
      publishNotReadyAddresses: true
      activeVaultPodOnly: false
      serviceType: "ClusterIP"
      serviceNodePort: null
      externalPort: 8200
      targetPort: 8200
      serviceIPFamilyPolicy: ""
      serviceIPFamilies: []
      externalTrafficPolicy: Cluster
      annotations: {}
    # secrets-store-csi-driver-provider-vault
    csi:
      # True if you want to install a secrets-store-csi-driver-provider-vault daemonset.
      #
      # Requires installing the secrets-store-csi-driver separately, see:
      # https://github.com/kubernetes-sigs/secrets-store-csi-driver#install-the-secrets-store-csi-driver
      #
      # With the driver and provider installed, you can mount Vault secrets into volumes
      # similar to the Vault Agent injector, and you can also sync those secrets into
      # Kubernetes secrets.
      enabled: false
      image:
        repository: "hashicorp/vault-csi-provider"
        tag: "1.5.1"
        pullPolicy: IfNotPresent
      volumes: null
      volumeMounts: null
      resources:
        requests:
          cpu: 50m
          memory: 128Mi
        limits:
          cpu: 50m
          memory: 128Mi

      hmacSecretName: ""
      hostNetwork: false
      daemonSet:
        updateStrategy:
          type: RollingUpdate
          maxUnavailable: ""
        annotations: {}
        providersDir: "/var/run/secrets-store-csi-providers"
        kubeletRootDir: "/var/lib/kubelet"
        extraLabels: {}
        securityContext:
          pod: {}
          container: {}
      pod:
        annotations: {}
        tolerations: []
        nodeSelector: {}
        affinity: {}
        extraLabels: {}
      agent:
        enabled: true
        extraArgs: []
        image:
          repository: "hashicorp/vault"
          tag: "1.20.4"
          pullPolicy: IfNotPresent
        logFormat: standard
        logLevel: info
        resources:
          requests:
            memory: 256Mi
            cpu: 250m
          limits:
            memory: 256Mi
            cpu: 250m
        securityContext:
          container:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
            runAsNonRoot: true
            runAsUser: 100
            runAsGroup: 1000
      priorityClassName: ""
      serviceAccount:
        annotations: {}
        extraLabels: {}
      readinessProbe:
        failureThreshold: 2
        initialDelaySeconds: 5
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 3
      livenessProbe:
        failureThreshold: 2
        initialDelaySeconds: 5
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 3
      logLevel: "info"
      debug: false
      extraArgs: []
    serverTelemetry:
      serviceMonitor:
        enabled: false
        selectors: {}
        interval: 30s
        scrapeTimeout: 10s
        tlsConfig: {}
        authorization: {}
        metricRelabelings: []

      prometheusRules:
          enabled: false
          selectors: {}
          rules: []
